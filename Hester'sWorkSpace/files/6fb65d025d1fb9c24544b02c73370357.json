{"author": "rg3", "code": "from __future__ import division, unicode_literals\n\nimport os\nimport time\nimport json\n\nfrom .common import FileDownloader\nfrom .http import HttpFD\nfrom ..utils import (\n    error_to_compat_str,\n    encodeFilename,\n    sanitize_open,\n    sanitized_Request,\n)\n\n\nclass HttpQuietDownloader(HttpFD):\n    def to_screen(self, *args, **kargs):\n        pass\n\n\nclass FragmentFD(FileDownloader):\n    \n\n    def report_retry_fragment(self, err, frag_index, count, retries):\n        self.to_screen(\n            '[download] Got server HTTP error: %s. Retrying fragment %d (attempt %d of %s)...'\n            % (error_to_compat_str(err), frag_index, count, self.format_retries(retries)))\n\n    def report_skip_fragment(self, frag_index):\n        self.to_screen('[download] Skipping fragment %d...' % frag_index)\n\n    def _prepare_url(self, info_dict, url):\n        headers = info_dict.get('http_headers')\n        return sanitized_Request(url, None, headers) if headers else url\n\n    def _prepare_and_start_frag_download(self, ctx):\n        self._prepare_frag_download(ctx)\n        self._start_frag_download(ctx)\n\n    @staticmethod\n    def __do_ytdl_file(ctx):\n        return not ctx['live'] and not ctx['tmpfilename'] == '-'\n\n    def _read_ytdl_file(self, ctx):\n        stream, _ = sanitize_open(self.ytdl_filename(ctx['filename']), 'r')\n        ctx['fragment_index'] = json.loads(stream.read())['downloader']['current_fragment']['index']\n        stream.close()\n\n    def _write_ytdl_file(self, ctx):\n        frag_index_stream, _ = sanitize_open(self.ytdl_filename(ctx['filename']), 'w')\n        downloader = {\n            'current_fragment': {\n                'index': ctx['fragment_index'],\n            },\n        }\n        if ctx.get('fragment_count') is not None:\n            downloader['fragment_count'] = ctx['fragment_count']\n        frag_index_stream.write(json.dumps({'downloader': downloader}))\n        frag_index_stream.close()\n\n    def _download_fragment(self, ctx, frag_url, info_dict, headers=None):\n        fragment_filename = '%s-Frag%d' % (ctx['tmpfilename'], ctx['fragment_index'])\n        success = ctx['dl'].download(fragment_filename, {\n            'url': frag_url,\n            'http_headers': headers or info_dict.get('http_headers'),\n        })\n        if not success:\n            return False, None\n        down, frag_sanitized = sanitize_open(fragment_filename, 'rb')\n        ctx['fragment_filename_sanitized'] = frag_sanitized\n        frag_content = down.read()\n        down.close()\n        return True, frag_content\n\n    def _append_fragment(self, ctx, frag_content):\n        try:\n            ctx['dest_stream'].write(frag_content)\n            ctx['dest_stream'].flush()\n        finally:\n            if self.__do_ytdl_file(ctx):\n                self._write_ytdl_file(ctx)\n            if not self.params.get('keep_fragments', False):\n                os.remove(encodeFilename(ctx['fragment_filename_sanitized']))\n            del ctx['fragment_filename_sanitized']\n\n    def _prepare_frag_download(self, ctx):\n        if 'live' not in ctx:\n            ctx['live'] = False\n        if not ctx['live']:\n            total_frags_str = '%d' % ctx['total_frags']\n            ad_frags = ctx.get('ad_frags', 0)\n            if ad_frags:\n                total_frags_str += ' (not including %d ad)' % ad_frags\n        else:\n            total_frags_str = 'unknown (live)'\n        self.to_screen(\n            '[%s] Total fragments: %s' % (self.FD_NAME, total_frags_str))\n        self.report_destination(ctx['filename'])\n        dl = HttpQuietDownloader(\n            self.ydl,\n            {\n                'continuedl': True,\n                'quiet': True,\n                'noprogress': True,\n                'ratelimit': self.params.get('ratelimit'),\n                'retries': self.params.get('retries', 0),\n                'nopart': self.params.get('nopart', False),\n                'test': self.params.get('test', False),\n            }\n        )\n        tmpfilename = self.temp_name(ctx['filename'])\n        open_mode = 'wb'\n        resume_len = 0\n\n        \n        if os.path.isfile(encodeFilename(tmpfilename)):\n            open_mode = 'ab'\n            resume_len = os.path.getsize(encodeFilename(tmpfilename))\n\n        \n        ctx.update({\n            'tmpfilename': tmpfilename,\n            'fragment_index': 0,\n        })\n\n        if self.__do_ytdl_file(ctx):\n            if os.path.isfile(encodeFilename(self.ytdl_filename(ctx['filename']))):\n                self._read_ytdl_file(ctx)\n                if ctx['fragment_index'] > 0 and resume_len == 0:\n                    self.report_warning(\n                        'Inconsistent state of incomplete fragment download. '\n                        'Restarting from the beginning...')\n                    ctx['fragment_index'] = resume_len = 0\n                    self._write_ytdl_file(ctx)\n            else:\n                self._write_ytdl_file(ctx)\n                assert ctx['fragment_index'] == 0\n\n        dest_stream, tmpfilename = sanitize_open(tmpfilename, open_mode)\n\n        ctx.update({\n            'dl': dl,\n            'dest_stream': dest_stream,\n            'tmpfilename': tmpfilename,\n            \n            'complete_frags_downloaded_bytes': resume_len,\n        })\n\n    def _start_frag_download(self, ctx):\n        total_frags = ctx['total_frags']\n        \n        \n        state = {\n            'status': 'downloading',\n            'downloaded_bytes': ctx['complete_frags_downloaded_bytes'],\n            'fragment_index': ctx['fragment_index'],\n            'fragment_count': total_frags,\n            'filename': ctx['filename'],\n            'tmpfilename': ctx['tmpfilename'],\n        }\n\n        start = time.time()\n        ctx.update({\n            'started': start,\n            \n            \n            'prev_frag_downloaded_bytes': 0,\n        })\n\n        def frag_progress_hook(s):\n            if s['status'] not in ('downloading', 'finished'):\n                return\n\n            time_now = time.time()\n            state['elapsed'] = time_now - start\n            frag_total_bytes = s.get('total_bytes') or 0\n            if not ctx['live']:\n                estimated_size = (\n                    (ctx['complete_frags_downloaded_bytes'] + frag_total_bytes) /\n                    (state['fragment_index'] + 1) * total_frags)\n                state['total_bytes_estimate'] = estimated_size\n\n            if s['status'] == 'finished':\n                state['fragment_index'] += 1\n                ctx['fragment_index'] = state['fragment_index']\n                state['downloaded_bytes'] += frag_total_bytes - ctx['prev_frag_downloaded_bytes']\n                ctx['complete_frags_downloaded_bytes'] = state['downloaded_bytes']\n                ctx['prev_frag_downloaded_bytes'] = 0\n            else:\n                frag_downloaded_bytes = s['downloaded_bytes']\n                state['downloaded_bytes'] += frag_downloaded_bytes - ctx['prev_frag_downloaded_bytes']\n                if not ctx['live']:\n                    state['eta'] = self.calc_eta(\n                        start, time_now, estimated_size,\n                        state['downloaded_bytes'])\n                state['speed'] = s.get('speed') or ctx.get('speed')\n                ctx['speed'] = state['speed']\n                ctx['prev_frag_downloaded_bytes'] = frag_downloaded_bytes\n            self._hook_progress(state)\n\n        ctx['dl'].add_progress_hook(frag_progress_hook)\n\n        return start\n\n    def _finish_frag_download(self, ctx):\n        ctx['dest_stream'].close()\n        if self.__do_ytdl_file(ctx):\n            ytdl_filename = encodeFilename(self.ytdl_filename(ctx['filename']))\n            if os.path.isfile(ytdl_filename):\n                os.remove(ytdl_filename)\n        elapsed = time.time() - ctx['started']\n        self.try_rename(ctx['tmpfilename'], ctx['filename'])\n        fsize = os.path.getsize(encodeFilename(ctx['filename']))\n\n        self._hook_progress({\n            'downloaded_bytes': fsize,\n            'total_bytes': fsize,\n            'filename': ctx['filename'],\n            'status': 'finished',\n            'elapsed': elapsed,\n        })\n", "comments": "\n    A base file downloader class for fragmented media (e.g. f4m/m3u8 manifests).\n\n    Available options:\n\n    fragment_retries:   Number of times to retry a fragment for HTTP error (DASH\n                        and hlsnative only)\n    skip_unavailable_fragments:\n                        Skip unavailable fragments (DASH and hlsnative only)\n    keep_fragments:     Keep downloaded fragments on disk after downloading is\n                        finished\n\n    For each incomplete fragment download youtube-dl keeps on disk a special\n    bookkeeping file with download state and metadata (in future such files will\n    be used for any incomplete download handled by youtube-dl). This file is\n    used to properly handle resuming, check download file consistency and detect\n    potential errors. The file has a .ytdl extension and represents a standard\n    JSON file of the following format:\n\n    extractor:\n        Dictionary of extractor related data. TBD.\n\n    downloader:\n        Dictionary of downloader related data. May contain following data:\n            current_fragment:\n                Dictionary with current (being downloaded) fragment data:\n                index:  0-based index of current fragment among all fragments\n            fragment_count:\n                Total count of fragments\n\n    This feature is experimental and file format may change in future.\n    \n \n# Establish possible resume length\n# Should be initialized before ytdl file check\n# Total complete fragments downloaded so far in bytes\n# This dict stores the download progress, it's updated by the progress\n# hook\n# Amount of fragment's bytes downloaded by the time of the previous\n# frag progress hook invocation\n", "content": "from __future__ import division, unicode_literals\n\nimport os\nimport time\nimport json\n\nfrom .common import FileDownloader\nfrom .http import HttpFD\nfrom ..utils import (\n    error_to_compat_str,\n    encodeFilename,\n    sanitize_open,\n    sanitized_Request,\n)\n\n\nclass HttpQuietDownloader(HttpFD):\n    def to_screen(self, *args, **kargs):\n        pass\n\n\nclass FragmentFD(FileDownloader):\n    \"\"\"\n    A base file downloader class for fragmented media (e.g. f4m/m3u8 manifests).\n\n    Available options:\n\n    fragment_retries:   Number of times to retry a fragment for HTTP error (DASH\n                        and hlsnative only)\n    skip_unavailable_fragments:\n                        Skip unavailable fragments (DASH and hlsnative only)\n    keep_fragments:     Keep downloaded fragments on disk after downloading is\n                        finished\n\n    For each incomplete fragment download youtube-dl keeps on disk a special\n    bookkeeping file with download state and metadata (in future such files will\n    be used for any incomplete download handled by youtube-dl). This file is\n    used to properly handle resuming, check download file consistency and detect\n    potential errors. The file has a .ytdl extension and represents a standard\n    JSON file of the following format:\n\n    extractor:\n        Dictionary of extractor related data. TBD.\n\n    downloader:\n        Dictionary of downloader related data. May contain following data:\n            current_fragment:\n                Dictionary with current (being downloaded) fragment data:\n                index:  0-based index of current fragment among all fragments\n            fragment_count:\n                Total count of fragments\n\n    This feature is experimental and file format may change in future.\n    \"\"\"\n\n    def report_retry_fragment(self, err, frag_index, count, retries):\n        self.to_screen(\n            '[download] Got server HTTP error: %s. Retrying fragment %d (attempt %d of %s)...'\n            % (error_to_compat_str(err), frag_index, count, self.format_retries(retries)))\n\n    def report_skip_fragment(self, frag_index):\n        self.to_screen('[download] Skipping fragment %d...' % frag_index)\n\n    def _prepare_url(self, info_dict, url):\n        headers = info_dict.get('http_headers')\n        return sanitized_Request(url, None, headers) if headers else url\n\n    def _prepare_and_start_frag_download(self, ctx):\n        self._prepare_frag_download(ctx)\n        self._start_frag_download(ctx)\n\n    @staticmethod\n    def __do_ytdl_file(ctx):\n        return not ctx['live'] and not ctx['tmpfilename'] == '-'\n\n    def _read_ytdl_file(self, ctx):\n        stream, _ = sanitize_open(self.ytdl_filename(ctx['filename']), 'r')\n        ctx['fragment_index'] = json.loads(stream.read())['downloader']['current_fragment']['index']\n        stream.close()\n\n    def _write_ytdl_file(self, ctx):\n        frag_index_stream, _ = sanitize_open(self.ytdl_filename(ctx['filename']), 'w')\n        downloader = {\n            'current_fragment': {\n                'index': ctx['fragment_index'],\n            },\n        }\n        if ctx.get('fragment_count') is not None:\n            downloader['fragment_count'] = ctx['fragment_count']\n        frag_index_stream.write(json.dumps({'downloader': downloader}))\n        frag_index_stream.close()\n\n    def _download_fragment(self, ctx, frag_url, info_dict, headers=None):\n        fragment_filename = '%s-Frag%d' % (ctx['tmpfilename'], ctx['fragment_index'])\n        success = ctx['dl'].download(fragment_filename, {\n            'url': frag_url,\n            'http_headers': headers or info_dict.get('http_headers'),\n        })\n        if not success:\n            return False, None\n        down, frag_sanitized = sanitize_open(fragment_filename, 'rb')\n        ctx['fragment_filename_sanitized'] = frag_sanitized\n        frag_content = down.read()\n        down.close()\n        return True, frag_content\n\n    def _append_fragment(self, ctx, frag_content):\n        try:\n            ctx['dest_stream'].write(frag_content)\n            ctx['dest_stream'].flush()\n        finally:\n            if self.__do_ytdl_file(ctx):\n                self._write_ytdl_file(ctx)\n            if not self.params.get('keep_fragments', False):\n                os.remove(encodeFilename(ctx['fragment_filename_sanitized']))\n            del ctx['fragment_filename_sanitized']\n\n    def _prepare_frag_download(self, ctx):\n        if 'live' not in ctx:\n            ctx['live'] = False\n        if not ctx['live']:\n            total_frags_str = '%d' % ctx['total_frags']\n            ad_frags = ctx.get('ad_frags', 0)\n            if ad_frags:\n                total_frags_str += ' (not including %d ad)' % ad_frags\n        else:\n            total_frags_str = 'unknown (live)'\n        self.to_screen(\n            '[%s] Total fragments: %s' % (self.FD_NAME, total_frags_str))\n        self.report_destination(ctx['filename'])\n        dl = HttpQuietDownloader(\n            self.ydl,\n            {\n                'continuedl': True,\n                'quiet': True,\n                'noprogress': True,\n                'ratelimit': self.params.get('ratelimit'),\n                'retries': self.params.get('retries', 0),\n                'nopart': self.params.get('nopart', False),\n                'test': self.params.get('test', False),\n            }\n        )\n        tmpfilename = self.temp_name(ctx['filename'])\n        open_mode = 'wb'\n        resume_len = 0\n\n        # Establish possible resume length\n        if os.path.isfile(encodeFilename(tmpfilename)):\n            open_mode = 'ab'\n            resume_len = os.path.getsize(encodeFilename(tmpfilename))\n\n        # Should be initialized before ytdl file check\n        ctx.update({\n            'tmpfilename': tmpfilename,\n            'fragment_index': 0,\n        })\n\n        if self.__do_ytdl_file(ctx):\n            if os.path.isfile(encodeFilename(self.ytdl_filename(ctx['filename']))):\n                self._read_ytdl_file(ctx)\n                if ctx['fragment_index'] > 0 and resume_len == 0:\n                    self.report_warning(\n                        'Inconsistent state of incomplete fragment download. '\n                        'Restarting from the beginning...')\n                    ctx['fragment_index'] = resume_len = 0\n                    self._write_ytdl_file(ctx)\n            else:\n                self._write_ytdl_file(ctx)\n                assert ctx['fragment_index'] == 0\n\n        dest_stream, tmpfilename = sanitize_open(tmpfilename, open_mode)\n\n        ctx.update({\n            'dl': dl,\n            'dest_stream': dest_stream,\n            'tmpfilename': tmpfilename,\n            # Total complete fragments downloaded so far in bytes\n            'complete_frags_downloaded_bytes': resume_len,\n        })\n\n    def _start_frag_download(self, ctx):\n        total_frags = ctx['total_frags']\n        # This dict stores the download progress, it's updated by the progress\n        # hook\n        state = {\n            'status': 'downloading',\n            'downloaded_bytes': ctx['complete_frags_downloaded_bytes'],\n            'fragment_index': ctx['fragment_index'],\n            'fragment_count': total_frags,\n            'filename': ctx['filename'],\n            'tmpfilename': ctx['tmpfilename'],\n        }\n\n        start = time.time()\n        ctx.update({\n            'started': start,\n            # Amount of fragment's bytes downloaded by the time of the previous\n            # frag progress hook invocation\n            'prev_frag_downloaded_bytes': 0,\n        })\n\n        def frag_progress_hook(s):\n            if s['status'] not in ('downloading', 'finished'):\n                return\n\n            time_now = time.time()\n            state['elapsed'] = time_now - start\n            frag_total_bytes = s.get('total_bytes') or 0\n            if not ctx['live']:\n                estimated_size = (\n                    (ctx['complete_frags_downloaded_bytes'] + frag_total_bytes) /\n                    (state['fragment_index'] + 1) * total_frags)\n                state['total_bytes_estimate'] = estimated_size\n\n            if s['status'] == 'finished':\n                state['fragment_index'] += 1\n                ctx['fragment_index'] = state['fragment_index']\n                state['downloaded_bytes'] += frag_total_bytes - ctx['prev_frag_downloaded_bytes']\n                ctx['complete_frags_downloaded_bytes'] = state['downloaded_bytes']\n                ctx['prev_frag_downloaded_bytes'] = 0\n            else:\n                frag_downloaded_bytes = s['downloaded_bytes']\n                state['downloaded_bytes'] += frag_downloaded_bytes - ctx['prev_frag_downloaded_bytes']\n                if not ctx['live']:\n                    state['eta'] = self.calc_eta(\n                        start, time_now, estimated_size,\n                        state['downloaded_bytes'])\n                state['speed'] = s.get('speed') or ctx.get('speed')\n                ctx['speed'] = state['speed']\n                ctx['prev_frag_downloaded_bytes'] = frag_downloaded_bytes\n            self._hook_progress(state)\n\n        ctx['dl'].add_progress_hook(frag_progress_hook)\n\n        return start\n\n    def _finish_frag_download(self, ctx):\n        ctx['dest_stream'].close()\n        if self.__do_ytdl_file(ctx):\n            ytdl_filename = encodeFilename(self.ytdl_filename(ctx['filename']))\n            if os.path.isfile(ytdl_filename):\n                os.remove(ytdl_filename)\n        elapsed = time.time() - ctx['started']\n        self.try_rename(ctx['tmpfilename'], ctx['filename'])\n        fsize = os.path.getsize(encodeFilename(ctx['filename']))\n\n        self._hook_progress({\n            'downloaded_bytes': fsize,\n            'total_bytes': fsize,\n            'filename': ctx['filename'],\n            'status': 'finished',\n            'elapsed': elapsed,\n        })\n", "description": "Command-line program to download videos from YouTube.com and other video sites", "file_name": "fragment.py", "language": "Python", "project_name": "youtube-dl", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/rg3_youtube-dl/rg3-youtube-dl-6202f08/youtube_dl/downloader/fragment.py", "save_time": "", "source": "", "update_at": "2018-03-07T09:18:39Z", "url": "https://github.com/rg3/youtube-dl", "wiki": false}