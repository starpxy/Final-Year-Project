{"author": "nvbn", "code": "from imp import load_source\nimport os\nimport sys\nfrom warnings import warn\nfrom six import text_type\nfrom . import const\nfrom .system import Path\n\n\nclass Settings(dict):\n    def __getattr__(self, item):\n        return self.get(item)\n\n    def __setattr__(self, key, value):\n        self[key] = value\n\n    def init(self, args=None):\n        \n        if not args:\n            return {}\n\n        from_args = {}\n        if args.yes:\n            from_args['require_confirmation'] = not args.yes\n        if args.debug:\n            from_args['debug'] = args.debug\n        if args.repeat:\n            from_args['repeat'] = args.repeat\n        return from_args\n\n\nsettings = Settings(const.DEFAULT_SETTINGS)\n", "comments": "Fills `settings` with values from `settings.py` and env.\"\"\"\n        from .logs import exception\n\n        self._setup_user_dir()\n        self._init_settings_file()\n\n        try:\n            self.update(self._settings_from_file())\n        except Exception:\n            exception(\"Can't load settings from file\", sys.exc_info())\n\n        try:\n            self.update(self._settings_from_env())\n        except Exception:\n            exception(\"Can't load settings from env\", sys.exc_info())\n\n        self.update(self._settings_from_args(args))\n\n    def _init_settings_file(self):\n        settings_path = self.user_dir.joinpath('settings.py')\n        if not settings_path.is_file():\n            with settings_path.open(mode='w') as settings_file:\n                settings_file.write(const.SETTINGS_HEADER)\n                for setting in const.DEFAULT_SETTINGS.items():\n                    settings_file.write(u'# {} = {}\\n'.format(*setting))\n\n    def _get_user_dir_path(self):\n        \"\"\"Returns Path object representing the user config resource\"\"\"\n        xdg_config_home = os.environ.get('XDG_CONFIG_HOME', '~/.config')\n        user_dir = Path(xdg_config_home, 'thefuck').expanduser()\n        legacy_user_dir = Path('~', '.thefuck').expanduser()\n\n        # For backward compatibility use legacy '~/.thefuck' if it exists:\n        if legacy_user_dir.is_dir():\n            warn(u'Config path {} is deprecated. Please move to {}'.format(\n                legacy_user_dir, user_dir))\n            return legacy_user_dir\n        else:\n            return user_dir\n\n    def _setup_user_dir(self):\n        \"\"\"Returns user config dir, create it when it doesn't exist.\"\"\"\n        user_dir = self._get_user_dir_path()\n\n        rules_dir = user_dir.joinpath('rules')\n        if not rules_dir.is_dir():\n            rules_dir.mkdir(parents=True)\n        self.user_dir = user_dir\n\n    def _settings_from_file(self):\n        \"\"\"Loads settings from file.\"\"\"\n        settings = load_source(\n            'settings', text_type(self.user_dir.joinpath('settings.py')))\n        return {key: getattr(settings, key)\n                for key in const.DEFAULT_SETTINGS.keys()\n                if hasattr(settings, key)}\n\n    def _rules_from_env(self, val):\n        \"\"\"Transforms rules list from env-string to python.\"\"\"\n        val = val.split(':')\n        if 'DEFAULT_RULES' in val:\n            val = const.DEFAULT_RULES + [rule for rule in val if rule != 'DEFAULT_RULES']\n        return val\n\n    def _priority_from_env(self, val):\n        \"\"\"Gets priority pairs from env.\"\"\"\n        for part in val.split(':'):\n            try:\n                rule, priority = part.split('=')\n                yield rule, int(priority)\n            except ValueError:\n                continue\n\n    def _val_from_env(self, env, attr):\n        \"\"\"Transforms env-strings to python.\"\"\"\n        val = os.environ[env]\n        if attr in ('rules', 'exclude_rules'):\n            return self._rules_from_env(val)\n        elif attr == 'priority':\n            return dict(self._priority_from_env(val))\n        elif attr in ('wait_command', 'history_limit', 'wait_slow_command'):\n            return int(val)\n        elif attr in ('require_confirmation', 'no_colors', 'debug',\n                      'alter_history', 'instant_mode'):\n            return val.lower() == 'true'\n        elif attr == 'slow_commands':\n            return val.split(':')\n        else:\n            return val\n\n    def _settings_from_env(self):\n        \"\"\"Loads settings from env.\"\"\"\n        return {attr: self._val_from_env(env, attr)\n                for env, attr in const.ENV_TO_ATTR.items()\n                if env in os.environ}\n\n    def _settings_from_args(self, args):\n        \"\"\"Loads settings from args.\n.\n", "content": "from imp import load_source\nimport os\nimport sys\nfrom warnings import warn\nfrom six import text_type\nfrom . import const\nfrom .system import Path\n\n\nclass Settings(dict):\n    def __getattr__(self, item):\n        return self.get(item)\n\n    def __setattr__(self, key, value):\n        self[key] = value\n\n    def init(self, args=None):\n        \"\"\"Fills `settings` with values from `settings.py` and env.\"\"\"\n        from .logs import exception\n\n        self._setup_user_dir()\n        self._init_settings_file()\n\n        try:\n            self.update(self._settings_from_file())\n        except Exception:\n            exception(\"Can't load settings from file\", sys.exc_info())\n\n        try:\n            self.update(self._settings_from_env())\n        except Exception:\n            exception(\"Can't load settings from env\", sys.exc_info())\n\n        self.update(self._settings_from_args(args))\n\n    def _init_settings_file(self):\n        settings_path = self.user_dir.joinpath('settings.py')\n        if not settings_path.is_file():\n            with settings_path.open(mode='w') as settings_file:\n                settings_file.write(const.SETTINGS_HEADER)\n                for setting in const.DEFAULT_SETTINGS.items():\n                    settings_file.write(u'# {} = {}\\n'.format(*setting))\n\n    def _get_user_dir_path(self):\n        \"\"\"Returns Path object representing the user config resource\"\"\"\n        xdg_config_home = os.environ.get('XDG_CONFIG_HOME', '~/.config')\n        user_dir = Path(xdg_config_home, 'thefuck').expanduser()\n        legacy_user_dir = Path('~', '.thefuck').expanduser()\n\n        # For backward compatibility use legacy '~/.thefuck' if it exists:\n        if legacy_user_dir.is_dir():\n            warn(u'Config path {} is deprecated. Please move to {}'.format(\n                legacy_user_dir, user_dir))\n            return legacy_user_dir\n        else:\n            return user_dir\n\n    def _setup_user_dir(self):\n        \"\"\"Returns user config dir, create it when it doesn't exist.\"\"\"\n        user_dir = self._get_user_dir_path()\n\n        rules_dir = user_dir.joinpath('rules')\n        if not rules_dir.is_dir():\n            rules_dir.mkdir(parents=True)\n        self.user_dir = user_dir\n\n    def _settings_from_file(self):\n        \"\"\"Loads settings from file.\"\"\"\n        settings = load_source(\n            'settings', text_type(self.user_dir.joinpath('settings.py')))\n        return {key: getattr(settings, key)\n                for key in const.DEFAULT_SETTINGS.keys()\n                if hasattr(settings, key)}\n\n    def _rules_from_env(self, val):\n        \"\"\"Transforms rules list from env-string to python.\"\"\"\n        val = val.split(':')\n        if 'DEFAULT_RULES' in val:\n            val = const.DEFAULT_RULES + [rule for rule in val if rule != 'DEFAULT_RULES']\n        return val\n\n    def _priority_from_env(self, val):\n        \"\"\"Gets priority pairs from env.\"\"\"\n        for part in val.split(':'):\n            try:\n                rule, priority = part.split('=')\n                yield rule, int(priority)\n            except ValueError:\n                continue\n\n    def _val_from_env(self, env, attr):\n        \"\"\"Transforms env-strings to python.\"\"\"\n        val = os.environ[env]\n        if attr in ('rules', 'exclude_rules'):\n            return self._rules_from_env(val)\n        elif attr == 'priority':\n            return dict(self._priority_from_env(val))\n        elif attr in ('wait_command', 'history_limit', 'wait_slow_command'):\n            return int(val)\n        elif attr in ('require_confirmation', 'no_colors', 'debug',\n                      'alter_history', 'instant_mode'):\n            return val.lower() == 'true'\n        elif attr == 'slow_commands':\n            return val.split(':')\n        else:\n            return val\n\n    def _settings_from_env(self):\n        \"\"\"Loads settings from env.\"\"\"\n        return {attr: self._val_from_env(env, attr)\n                for env, attr in const.ENV_TO_ATTR.items()\n                if env in os.environ}\n\n    def _settings_from_args(self, args):\n        \"\"\"Loads settings from args.\"\"\"\n        if not args:\n            return {}\n\n        from_args = {}\n        if args.yes:\n            from_args['require_confirmation'] = not args.yes\n        if args.debug:\n            from_args['debug'] = args.debug\n        if args.repeat:\n            from_args['repeat'] = args.repeat\n        return from_args\n\n\nsettings = Settings(const.DEFAULT_SETTINGS)\n", "description": "Magnificent app which corrects your previous console command.", "file_name": "conf.py", "language": "Python", "project_name": "thefuck", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/nvbn_thefuck/nvbn-thefuck-284d49d/thefuck/conf.py", "save_time": "", "source": "", "update_at": "2018-03-07T09:34:29Z", "url": "https://github.com/nvbn/thefuck", "wiki": true}